// 高精度运算


/* Code
#include<iostream>

using namespace std;

const int N = 3000;

int main()
{
    int a[N] = {1};
    int n ;
    cin >> n; 
    int m = 1;
    
    for (int i = 0; i < n; i ++ )
    {
        int t= 0;
        for (int j = 0; j < m; j ++ )
        {
            t += a[j] * 2;
            a[j] = t % 10;
            t /= 10;
        }
        if (t) a[m ++ ] = 1;
    }
    for (int i = m - 1;i >= 0; i -- ) cout << a[i];
    cout << endl;
*/



// 747. 数组的左上半部分(12x12数组左上半部分元素和,平均值)

// 输入一个二维数组 M[12][12]，根据输入的要求，求出二维数组的左上半部分元素的平均值或元素的和。

// 左上半部分是指次对角线上方的部分，如下图所示，黄色部分为对角线，绿色部分为左上半部分：

// UOJ_1185.png

// 输入格式
// 第一行输入一个大写字母，若为 S，则表示需要求出左上半部分的元素的和，若为 M，则表示需要求出左上半部分的元素的平均值。

// 接下来 12 行，每行包含 12 个用空格隔开的浮点数，表示这个二维数组，其中第 i+1 行的第 j+1 个数表示数组元素 M[i][j]。

// 输出格式
// 输出一个数，表示所求的平均数或和的值，保留一位小数。

// 数据范围
// −100.0≤M[i][j]≤100.0
// 输入样例：
// M
// -0.4 -7.7 8.8 1.9 -9.1 -8.8 4.4 -8.8 0.5 -5.8 1.3 -8.0
// -1.7 -4.6 -7.0 4.7 9.6 2.0 8.2 -6.4 2.2 2.3 7.3 -0.4
// -8.1 4.0 -6.9 8.1 6.2 2.5 -0.2 -6.2 -1.5 9.4 -9.8 -3.5
// -2.3 8.4 1.3 1.4 -7.7 1.3 -2.3 -0.1 -5.4 -7.6 2.5 -7.7
// 6.2 -1.5 -6.9 -3.9 -7.9 5.1 -8.8 9.0 -7.4 -3.9 -2.7 0.9
// -6.8 0.8 -9.9 9.1 -3.7 -8.4 4.4 9.8 -6.3 -6.4 -3.7 2.8
// -3.8 5.0 -4.6 2.0 4.0 9.2 -8.9 0.5 -3.9 6.5 -4.3 -9.9
// -7.2 6.2 -1.2 4.1 -7.4 -4.6 4.7 -0.4 -2.2 -9.1 0.4 -5.8
// 9.1 -6.4 9.2 0.7 10.0 -5.7 -9.7 -4.4 4.7 4.7 4.9 2.1
// -1.2 -6.2 -8.2 7.0 -5.3 4.9 5.5 7.2 3.4 3.2 -0.2 9.9
// -6.9 -6.2 5.1 8.5 7.1 -0.8 -0.7 2.7 -6.0 4.2 -8.2 -9.8
// -3.5 7.7 5.4 2.8 1.6 -1.0 6.1 7.7 -6.5 -8.3 -8.5 9.4
// 输出样例：
// -0.8


/* Code
#include <iostream>

using namespace std;

int main()
{
    char c;
    scanf ("%c", &c);
    double a [12][12];
    for (int i = 0; i < 12; i ++ )
        for (int j = 0; j < 12; j ++ ) scanf("%lf", &a[i][j]);
    
    int b = 0;
    double res = 0;   
    for (int i = 0; i < 12; i ++ )
        for (int j = 0; j < 11 - i; j ++ )
        {
            b ++;
            res += a[i][j];
        }
    if (c == 'S') printf("%.1lf", res);
    else if (c == 'M') printf("%.1lf", res / b);
    
    return 0;
}
*/



// 745. 数组的右上半部分(12x12数组右下半部分元素和,平均值)

// 输入一个二维数组 M[12][12]，根据输入的要求，求出二维数组的右上半部分元素的平均值或元素的和。

// 右上半部分是指主对角线上方的部分，如下图所示，黄色部分为对角线，绿色部分为右上半部分：

// UOJ_1183.png

// 输入格式
// 第一行输入一个大写字母，若为 S，则表示需要求出右上半部分的元素的和，若为 M，则表示需要求出右上半部分的元素的平均值。

// 接下来 12 行，每行包含 12 个用空格隔开的浮点数，表示这个二维数组，其中第 i+1 行的第 j+1 个数表示数组元素 M[i][j]。

// 输出格式
// 输出一个数，表示所求的平均数或元素的和的值，保留一位小数。

// 数据范围
// −100.0≤M[i][j]≤100.0
// 输入样例：
// M
// -6.5 8.2 0.7 9.0 0.8 -4.3 0.9 -0.0 -7.9 7.1 -1.6 4.6
// -9.4 -9.0 1.5 -9.0 -5.1 -0.5 -2.8 -9.1 8.0 -6.9 -5.5 -6.6
// -6.8 0.3 3.8 6.1 -9.9 -9.3 8.5 8.6 5.0 6.9 -3.6 -3.0
// -0.8 -1.6 -7.3 -6.7 4.4 -9.1 -9.0 1.6 0.3 -6.0 6.0 -0.8
// -0.8 -6.0 -4.9 -3.9 6.4 6.2 -4.2 -0.9 7.9 1.6 -8.2 -9.2
// 7.8 -5.8 -5.8 -5.8 7.2 0.5 -7.9 1.2 -6.8 -9.1 0.3 -1.4
// 4.3 -7.2 3.5 -6.4 -9.1 -6.0 3.5 -5.1 -5.6 -6.9 -9.1 -2.1
// -7.6 -7.1 0.7 -1.7 5.0 -9.0 1.4 -6.2 7.6 4.8 -7.5 4.0
// -0.2 0.3 -4.2 8.4 0.7 -6.4 -2.7 3.5 -0.9 3.7 0.9 -2.7
// 7.1 0.1 8.4 -5.1 -7.9 -0.5 -5.3 -5.7 -4.6 9.6 -8.3 7.0
// 9.6 -9.8 3.3 -9.9 -6.8 6.7 3.1 1.2 -9.5 -4.3 -1.7 -9.7
// 1.8 5.0 8.3 -0.7 -0.9 3.2 2.5 0.5 7.3 8.3 0.3 0.9
// 输出样例：
// -1.2


/* Code
#include <iostream>

using namespace std;

int main()
{
    char c;
    scanf ("%c", &c);
    double a [12][12];
    int b1 = 0;
    double res1 = 0; 
    for (int i = 0; i < 12; i ++ )
        for (int j = 0; j < 12; j ++ ) 
        {
            b1 ++ ;
            res1 += a[i][j];
            scanf("%lf", &a[i][j]);
        }
    
    
    int b2 = 0;
    double res2 = 0;   
    for (int i = 0; i < 12; i ++ )
        for (int j = 0; j < 12 - i; j ++ )
        {
            b2 ++ ;
            res2 += a[i][j];
        }
    if (c == 'S') printf("%.1lf", res1 - res2);
    else if (c == 'M') printf("%.1lf", (res1 - res2) / (b1 - b2)); 
    
    return 0;
}
*/